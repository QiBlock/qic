//! Generated by `cargo xtask codegen grammar`, do not edit by hand.

#![allow(bad_style)]
#[doc = r" The kind of syntax node, e.g. `IDENT`."]
#[derive(Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    WALRUS,
    ARROW,
    BRACKET_CURLY_LEFT,
    BRACKET_CURLY_RIGHT,
    PARENTHESIS_LEFT,
    PARENTHESIS_RIGHT,
    COMMA,
    COLON,
    BREAK_KW,
    CASE_KW,
    CODE_KW,
    CONTINUE_KW,
    DEFAULT_KW,
    FALSE_KW,
    FOR_KW,
    FUNCTION_KW,
    IF_KW,
    LEAVE_KW,
    LET_KW,
    OBJECT_KW,
    SWITCH_KW,
    TRUE_KW,
    DATA_KW,
    DECIMAL_NUMBER,
    HEX_LITERAL,
    HEX_NUMBER,
    STRING_LITERAL,
    COMMENT,
    ERROR,
    IDENT,
    WHITESPACE,
    ASSIGNMENT,
    BLOCK,
    BREAK_CONTINUE,
    CASE,
    CODE,
    DATA,
    DEFAULT,
    EXPRESSION,
    FOR_LOOP,
    FUNCTION_CALL,
    FUNCTION_DEFINITION,
    IDENTIFIER_LIST,
    IF,
    LEAVE,
    LITERAL,
    OBJECT,
    SWITCH,
    TYPED_IDENTIFIER,
    TYPED_IDENTIFIER_LIST,
    TYPE_NAME,
    VARIABLE_DECLARATION,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    #[allow(unreachable_patterns)]
    pub const fn text(self) -> &'static str {
        match self {
            TOMBSTONE
            | EOF
            | __LAST
            | DECIMAL_NUMBER
            | HEX_LITERAL
            | HEX_NUMBER
            | STRING_LITERAL
            | ASSIGNMENT
            | BLOCK
            | BREAK_CONTINUE
            | CASE
            | CODE
            | DATA
            | DEFAULT
            | EXPRESSION
            | FOR_LOOP
            | FUNCTION_CALL
            | FUNCTION_DEFINITION
            | IDENTIFIER_LIST
            | IF
            | LEAVE
            | LITERAL
            | OBJECT
            | SWITCH
            | TYPED_IDENTIFIER
            | TYPED_IDENTIFIER_LIST
            | TYPE_NAME
            | VARIABLE_DECLARATION
            | COMMENT
            | ERROR
            | IDENT
            | WHITESPACE => panic!("no text for these `SyntaxKind`s"),
            WALRUS => ":=",
            ARROW => "->",
            BRACKET_CURLY_LEFT => "{",
            BRACKET_CURLY_RIGHT => "}",
            PARENTHESIS_LEFT => "(",
            PARENTHESIS_RIGHT => ")",
            COMMA => ",",
            COLON => ":",
            BREAK_KW => "break",
            CASE_KW => "case",
            CODE_KW => "code",
            CONTINUE_KW => "continue",
            DEFAULT_KW => "default",
            FALSE_KW => "false",
            FOR_KW => "for",
            FUNCTION_KW => "function",
            IF_KW => "if",
            LEAVE_KW => "leave",
            LET_KW => "let",
            OBJECT_KW => "object",
            SWITCH_KW => "switch",
            TRUE_KW => "true",
            DATA_KW => "data",
        }
    }
    #[doc = r" Strict keywords are identifiers that are always considered keywords."]
    pub fn is_strict_keyword(self) -> bool {
        matches!(
            self,
            BREAK_KW
                | CASE_KW
                | CODE_KW
                | CONTINUE_KW
                | DEFAULT_KW
                | FALSE_KW
                | FOR_KW
                | FUNCTION_KW
                | IF_KW
                | LEAVE_KW
                | LET_KW
                | OBJECT_KW
                | SWITCH_KW
                | TRUE_KW
        ) || match self {
            _ => false,
        }
    }
    #[doc = r" Weak keywords are identifiers that are considered keywords only in certain contexts."]
    pub fn is_contextual_keyword(self) -> bool {
        match self {
            DATA_KW => true,
            _ => false,
        }
    }
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            BREAK_KW
                | CASE_KW
                | CODE_KW
                | CONTINUE_KW
                | DEFAULT_KW
                | FALSE_KW
                | FOR_KW
                | FUNCTION_KW
                | IF_KW
                | LEAVE_KW
                | LET_KW
                | OBJECT_KW
                | SWITCH_KW
                | TRUE_KW
        ) || match self {
            DATA_KW => true,
            _ => false,
        }
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            WALRUS
                | ARROW
                | BRACKET_CURLY_LEFT
                | BRACKET_CURLY_RIGHT
                | PARENTHESIS_LEFT
                | PARENTHESIS_RIGHT
                | COMMA
                | COLON
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(self, DECIMAL_NUMBER | HEX_LITERAL | HEX_NUMBER | STRING_LITERAL)
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "break" => BREAK_KW,
            "case" => CASE_KW,
            "code" => CODE_KW,
            "continue" => CONTINUE_KW,
            "default" => DEFAULT_KW,
            "false" => FALSE_KW,
            "for" => FOR_KW,
            "function" => FUNCTION_KW,
            "if" => IF_KW,
            "leave" => LEAVE_KW,
            "let" => LET_KW,
            "object" => OBJECT_KW,
            "switch" => SWITCH_KW,
            "true" => TRUE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_contextual_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "data" => DATA_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '{' => BRACKET_CURLY_LEFT,
            '}' => BRACKET_CURLY_RIGHT,
            '(' => PARENTHESIS_LEFT,
            ')' => PARENTHESIS_RIGHT,
            ',' => COMMA,
            ':' => COLON,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T_ { [:=] => { $ crate :: SyntaxKind :: WALRUS } ; [->] => { $ crate :: SyntaxKind :: ARROW } ; ['{'] => { $ crate :: SyntaxKind :: BRACKET_CURLY_LEFT } ; ['}'] => { $ crate :: SyntaxKind :: BRACKET_CURLY_RIGHT } ; ['('] => { $ crate :: SyntaxKind :: PARENTHESIS_LEFT } ; [')'] => { $ crate :: SyntaxKind :: PARENTHESIS_RIGHT } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [case] => { $ crate :: SyntaxKind :: CASE_KW } ; [code] => { $ crate :: SyntaxKind :: CODE_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [function] => { $ crate :: SyntaxKind :: FUNCTION_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [leave] => { $ crate :: SyntaxKind :: LEAVE_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [object] => { $ crate :: SyntaxKind :: OBJECT_KW } ; [switch] => { $ crate :: SyntaxKind :: SWITCH_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [data] => { $ crate :: SyntaxKind :: DATA_KW } ; [decimal_number] => { $ crate :: SyntaxKind :: DECIMAL_NUMBER } ; [hex_number] => { $ crate :: SyntaxKind :: HEX_NUMBER } ; [string_literal] => { $ crate :: SyntaxKind :: STRING_LITERAL } ; [hex_literal] => { $ crate :: SyntaxKind :: HEX_LITERAL } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; }
impl ::core::marker::Copy for SyntaxKind {}
impl ::core::clone::Clone for SyntaxKind {
    #[inline]
    fn clone(&self) -> Self { *self }
}
impl ::core::cmp::PartialEq for SyntaxKind {
    #[inline]
    fn eq(&self, other: &Self) -> bool { (*self as u16) == (*other as u16) }
}
impl ::core::cmp::Eq for SyntaxKind {}
impl ::core::cmp::PartialOrd for SyntaxKind {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl ::core::cmp::Ord for SyntaxKind {
    #[inline]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering { (*self as u16).cmp(&(*other as u16)) }
}
impl ::core::hash::Hash for SyntaxKind {
    fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
        ::core::mem::discriminant(self).hash(state);
    }
}
